\documentclass{llncs}
%%
%\setlength{\textheight}{23cm}
\setlength{\textwidth}{13.5cm}
\advance\evensidemargin by -.65cm
\advance\oddsidemargin by -.65cm
%\setlength{\hoffset}{-1cm}
%\renewcommand{\baselinestretch}{0.95}

%\setlength{\abovedisplayskip}{3pt plus 0pt minus 0pt}
%\setlength{\abovedisplayskip}{3pt}
%\setlength{\abovedisplayshortskip}{3pt}
%\setlength{\belowdisplayskip}{3pt}
%\setlength{\belowdisplayshortskip}{3pt}

\usepackage{fleqn}
\usepackage{listings}
\usepackage{math}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{bcprules}
\usepackage[scaled=0.848971]{luximono} % This is for 11 pt Default font
\usepackage[T1]{fontenc}

% Prooftree formatting
\usepackage{prooftree}


\usepackage[bookmarks=true]{hyperref}
\usepackage{bookmark}

% support for generating PDF files
%\newif\ifpdf
%    \ifx\pdfoutput\undefined
%    \pdffalse
%\else
%    \pdftrue
%    \pdfoutput=1
%\fi

%versions
% Use dependent function types
\newif\ifdep\depfalse

\lstset{
  literate=
  {=>}{$\Rightarrow\;$}{2}
  {<:}{$<:\;$}{1}
}

\lstdefinelanguage{scala}{% 
       morekeywords={% 
                try, catch, throw, private, public, protected, import, package, implicit, final, package, trait, type, class, val, def, var, if, for, this, else, extends, with, while, new, abstract, object, case, match, sealed,override},
         sensitive=t, % 
   morecomment=[s]{/*}{*/},morecomment=[l]{\//},% 
   mathescape,
%   escapeinside={/*\%}{*/},%
   rangeprefix= /*< ,rangesuffix= >*/,%
   morestring=[d]{"}% 
 }
 
\lstset{breaklines=true,language=scala} 

\def\c{\lstinline}  % shorter version so you can write \c|String[Foo]|
                    % -- \def must be in same file as uses for this to
                    % work...
\newcommand{\lstref}[1]{Listing~\ref{#1}}
\newcommand{\Lstref}[1]{Listing~\ref{#1}} % only capitalise at beginning of sentence?
\newcommand{\secref}[1]{Section~\ref{#1}}
\newcommand{\Secref}[1]{Section~\ref{#1}} % only capitalise at beginning of sentence?



% \lstset{basicstyle=\footnotesize\ttfamily, breaklines=true, language=scala, tabsize=2, columns=fixed, mathescape=false,includerangemarker=false}
% thank you, Burak 
% (lstset tweaking stolen from
% http://lampsvn.epfl.ch/svn-repos/scala/scala/branches/typestate/docs/tstate-report/datasway.tex)
\lstset{
    xleftmargin=2em,%
    framesep=5pt,%
    frame=none,%
    captionpos=b,%
    fontadjust=true,%
    columns=[c]fixed,%
    keepspaces=false,%
    basewidth={0.56em, 0.52em},%
    tabsize=2,%
    basicstyle=\small\tt,% \small\tt
    commentstyle=\textit,%
    keywordstyle=\bfseries,%
    escapechar=\%,%
}

%% set latex/pdflatex specific stuff
%\ifpdf
%    \usepackage[pdftex,
%                hyperindex,
%                plainpages=false,
%                breaklinks,
%                colorlinks,
%                citecolor=black,
%                filecolor=black,
%                linkcolor=black,
%                pagecolor=black,
%                urlcolor=black]{hyperref}
%    \usepackage[pdftex]{graphicx}
%    \DeclareGraphicsExtensions{.jpg,.pdf}
%    \pdfcatalog {
%        /PageMode (/UseNone)
%    }
%    \usepackage{thumbpdf}
%    \usepackage[pdftex]{color}
%\else
%    \usepackage[ps2pdf]{hyperref}
%    \usepackage{graphicx}
%    \DeclareGraphicsExtensions{.eps,.jpg}
%    \usepackage{color}
%\fi

%\setlength{\parindent}{0pt}
%\setlength{\parskip}{5pt}

% verbfilter stuff
\newcommand{\prog}[1]{{\sl #1}}
\newenvironment{program}[1][10.5]
  {\fontsize{#1}{13.6}\tt\begin{tabbing}\hspace*{0.5\parindent}\=\+\kill}
  {\end{tabbing}\noindent}
\newcommand{\blockcomment}[1]{{\color{grayPoint3}#1}}
\newcommand{\linecomment}{\color{grayPoint3}}
\newcommand{\grey}{\color{grey}}

%\newenvironment{program}{\ \ \ \ \begin{minipage}{\textwidth}\renewcommand{\baselinestretch}{1.0}\sl\begin{tabbing}}{\end{tabbing}\end{minipage}}
\newcommand{\vem}{\bfseries}
\newcommand{\quotedstring}[1]{{#1}}
\newcommand{\typename}[1]{{#1}}
\newcommand{\literal}[1]{{#1}}

% comments and notes
\newcommand{\comment}[1]{}
%\newcommand{\note}[1]{{\bf $\clubsuit$ #1 $\spadesuit$}}

% figures
\newcommand{\figurebox}[1]
        {\fbox{\begin{minipage}{\textwidth} #1 \medskip\end{minipage}}}
\newcommand{\twofig}[3]
        {\begin{figure*}[t]#3\ \hrulefill\ 
        \caption{\label{#1}#2}\end{figure*}}
\newcommand{\boxfig}[3]
        {\begin{figure*}\figurebox{#3\caption{\label{#1}#2}}\end{figure*}}
\newcommand{\figref}[1]
        {Figure~\ref{#1}}

% typing rules (not used here)
\newcommand{\ttag}[1]{\mbox{\textsc{\small(#1)}}}
\newcommand{\infer}[3]{\mbox{#1 }\ba{c} #2 \\ \hline #3 \ea}
\newcommand{\irule}[2]{{\renewcommand{\arraystretch}{1.2}\ba{c} #1 
                        \\ \hline #2 \ea}}
\newlength{\trulemargin}
\newlength{\trulewidth}
\newlength{\srulewidth}
\setlength{\trulemargin}{1.75cm}
\setlength{\trulewidth}{83.7mm}
\setlength{\srulewidth}{6.0cm}
\newenvironment{trules}{$\vspace{0.5em}\ba{p{\trulemargin}@{~}p{\trulewidth}@{~}p{\trulemargin}}}{\ea$}
\newenvironment{srules}{$\vspace{0.5em}\ba{p{\trulemargin}@{~}p{\srulewidth}}}{\ea$}
\newcommand{\laxiom}[2]{\ttag{#1} & $ #2 \hfill\ }
\newcommand{\raxiom}[2]{\hfill #2 $& \hfill \ttag{#1}}
\newcommand{\caxiom}[2]{\ttag{#1} & $\hfill #2 \hfill $& \ }
\newcommand{\lrule}[3]{\laxiom{#1}{\irule{#2}{#3}}}
\newcommand{\rrule}[3]{\raxiom{#1}{\irule{#2}{#3}}}
\newcommand{\crule}[3]{\caxiom{#1}{\irule{#2}{#3}}}
\newcommand{\lsrule}[3]{\lsaxiom{#1}{\irule{#2}{#3}}}
\newcommand{\rsrule}[3]{\rsaxiom{#1}{\irule{#2}{#3}}}
\newcommand{\nl}{\end{trules}\\[0.5em] \begin{trules}}
\newcommand{\snl}{\end{srules}\\[0.5em] \begin{srules}}

% commas and semicolons
\newcommand{\comma}{,\,}
\newcommand{\commadots}{\comma \ldots \comma}
\newcommand{\semi}{;\mbox{;};}
\newcommand{\semidots}{\semi \ldots \semi}

% spacing
\newcommand{\gap}{\quad\quad}
\newcommand{\biggap}{\quad\quad\quad}
\newcommand{\nextline}{\\ \\}
\newcommand{\htabwidth}{0.5cm}
\newcommand{\tabwidth}{1cm}
\newcommand{\htab}{\hspace{\htabwidth}}
\newcommand{\tab}{\hspace{\tabwidth}}
\newcommand{\linesep}{\ \hrulefill \ \smallskip}

% math stuff
\newenvironment{myproof}{{\em Proof:}}{$\Box$}
\newenvironment{proofsketch}{{\em Proof Sketch:}}{$\Box$}
\newcommand{\Case}{{\em Case\ }}

% make ; a delimiter in math mode
% \mathcode`\;="8000 % Makes ; active in math mode
% {\catcode`\;=\active \gdef;{\;}}
% \mathchardef\semicolon="003B

% reserved words
\newcommand{\mathem}{\bf}

% brackets
\newcommand{\set}[1]{\{#1\}}
\newcommand{\sbs}[1]{\lquote #1 \rquote}

% arrays
\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}
\newcommand{\bda}{\[\ba}
\newcommand{\eda}{\ea\]}
\newcommand{\ei}{\end{array}}
\newcommand{\bcases}{\left\{\begin{array}{ll}}
\newcommand{\ecases}{\end{array}\right.}

% \cal ids
\renewcommand{\AA}{{\cal A}}
\newcommand{\BB}{{\cal B}}
\newcommand{\CC}{{\cal C}}
\newcommand{\DD}{{\cal D}}
\newcommand{\EE}{{\cal E}}
\newcommand{\FF}{{\cal F}}
\newcommand{\GG}{{\cal G}}
\newcommand{\HH}{{\cal H}}
\newcommand{\II}{{\cal I}}
\newcommand{\JJ}{{\cal J}}
\newcommand{\KK}{{\cal K}}
\newcommand{\LL}{{\cal L}}
\newcommand{\MM}{{\cal M}}
\newcommand{\NN}{{\cal N}}
\newcommand{\OO}{{\cal O}}
\newcommand{\PP}{{\cal P}}
\newcommand{\QQ}{{\cal Q}}
\newcommand{\RR}{{\cal R}}
\newcommand{\TT}{{\cal T}}
\newcommand{\UU}{{\cal U}}
\newcommand{\VV}{{\cal V}}
\newcommand{\WW}{{\cal W}}
\newcommand{\XX}{{\cal X}}
\newcommand{\YY}{{\cal Y}}
\newcommand{\ZZ}{{\cal Z}}

% misc symbols
\newcommand{\dhd}{\!\!\!\!\!\rightarrow}
\newcommand{\Dhd}{\!\!\!\!\!\Rightarrow}
\renewcommand{\ts}{\,\vdash\,}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\eg}{{\em e.g.}}

% misc identifiers
\newcommand{\dom}{\mbox{\sl dom}}
\newcommand{\fn}{\mbox{\sl fn}}
\newcommand{\bn}{\mbox{\sl bn}}
\newcommand{\sig}{\mbox{\sl sig}}
\newcommand{\IF}{\mbox{\mathem if}}
\newcommand{\OTHERWISE}{\mbox{\mathem otherwise}}
\newcommand{\expand}{\prec}
\newcommand{\weakexpand}{\prec^W}
\newcommand{\spcomma}{~,~}

%\newcommand{\inst}{\mbox{\mathem inst}}
\newcommand{\trans}[1]{\la\!\la#1\ra\!\ra}
\renewcommand{\remark}[1]{{\bf $\clubsuit$ #1 $\spadesuit$}}
\newcommand{\todo}[1]{\remark{to do: #1}}
%\newcommand{\J}{\justifies}
%\newcommand{\U}{\using}

% names
\newcommand{\Scala}{\mbox{\textsc{Scala}}}
\newcommand{\Java}{\mbox{\textsc{Java}}}

%\renewcommand\textfraction{.05}
%\renewcommand\floatpagefraction{.9}
%\renewcommand\topfraction{.8}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Language abstraction commands     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Relations
% Subtype 
\newcommand{\sub}{<:}
% Type assignment
\newcommand{\typ}{:}
\newcommand{\approxtyp}{:_{<:}}
% reduction
\newcommand{\reduces}{\;\rightarrow\;}
\newcommand{\resolves}{\Downarrow}
\newcommand{\irresolves}{\Updownarrow}
\newcommand{\optresolves}{\Updownarrow}
% well-formedness
\newcommand{\wf}{\;\mbox{\textbf{wf}}}
\newcommand{\wfe}{\;\mbox{\textbf{wfe}}}

%% Operators
% Type selection
\newcommand{\tsel}{\#}
% Function type
\newcommand{\tfun}{\rightarrow}
\newcommand{\dfun}[3]{(#1\!:\!#2) \Rightarrow #3}
% Conjunction
\newcommand{\tand}{\wedge}
% Disjunction
\newcommand{\tor}{\vee}
% Singleton type suffix
\newcommand{\sing}{.\textbf{type}}

%% Syntax
% Header for typing rules
\newcommand{\judgement}[2]{{\bf #1} \hfill #2}
% Refinement
\newcommand{\refine}[2]{\left\{#1 \Rightarrow #2 \right\}}
% Field definitions
\newcommand{\ldefs}[1]{\left\{#1\right\}}
% Member sequences
\newcommand{\seq}[1]{\overline{#1}}
% Lambda
\newcommand{\dabs}[3]{(#1\!:\!#2)\Rightarrow #3}
\newcommand{\abs}[3]{\lambda #1\!:\!#2.#3}
% Application
\newcommand{\app}[2]{#1\;#2}
% Method Application
\newcommand{\mapp}[3]{#1.#2(#3)}
% Substitution
\newcommand{\subst}[3]{[#1/#2]#3}
% Object creation
\newcommand{\new}[3]{\textbf{val }#1 = \textbf{new }#2 ;\; #3}
\newcommand{\anfmapp}[5]{\textbf{val }#1 = {#2.#3(#4)} ;\; #5}
\newcommand{\anfmexe}[5]{\textbf{val }#1 = {#2.#3\ldots\;#4} ;\; #5}
%\renewcommand{\new}[3]{#1 \leftarrow #2 \,\textbf{in}\, #3}
% Field declaration
\newcommand{\Ldecl}[3]{#1 : #2..#3}%{#1 \operatorname{>:} #2 \operatorname{<:} #3}
\newcommand{\ldecl}[2]{#1 : #2}
\newcommand{\mdecl}[3]{#1 : #2 \tfun #3}
% Top and Bottom
\newcommand{\Top}{\top}%{\textbf{Top}}
\newcommand{\Bot}{\bot}%\textbf{Bot}}
% Environment extension
%\newcommand{\envplus}[1]{\uplus \{ #1 \}}
\newcommand{\envplus}[1]{, #1}
% Reduction
\newcommand{\reduction}[4]{#1 \operatorname{|} #2 \reduces #3 \operatorname{|} #4}

%%%%%%%%%%%%%%%%%%%%%%%%
%%%% BEGIN DOCUMENT %%%%
%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\thispagestyle{plain}
\pagestyle{plain}
\mainmatter

\title{The DOT Calculus}
\author{Nada Amin, Tiark Rompf, Adriaan Moors, Martin Odersky}
\institute{EPFL}

\maketitle
\sloppy
\newcommand{\lindent}{\hspace{-4mm}}

\renewcommand{\abs}[3]{\ifdep \dabs #1 #2 #3 \else \lambda #1\!:\!#2.#3 \fi}

%\fontfamily{timesroman}

\begin{figure}
\figurebox{
%\renewcommand{\baselinestretch}{0.95}
\pdfbookmark[0]{Syntax}{syntax}
{\bf Syntax}\medskip
    
$\ba{l@{\hspace{0.2mm}}|@{\hspace{0.2mm}}l}
\ba[t]{l@{\hspace{10mm}}l}
x, y, z    & \lindent{\mbox{Variable}} \\
l          & \lindent{\mbox{Value label}}\\
m          & \lindent{\mbox{Method label}}\\[0.2em]
o          & \lindent{\mbox{Store location}}\\
v ::=      & \lindent{\mbox{Value}} \\
\gap o     & \mbox{location} \\[0.2em]
w ::=      & \lindent{\mbox{Syntactic Value}} \\
\gap v     & \mbox{value} \\[0.2em]
\gap x     & \mbox{variable} \\[0.2em]
p,q ::= & \lindent \mbox{Path} \\
\gap w & \mbox{value} \\
\gap p.l & \mbox{selection} \\
t ::=      & \lindent{\mbox{Term}} \\
\gap p     & \mbox{path} \\
\gap \new x c t & \mbox{new instance} \\
\gap \anfmapp x p m p t & \mbox{method invocation} \\[0.2em]
\gap \anfmexe x o m t t & \mbox{pending met. exec.} \\[0.2em]
d ::= & \lindent{\mbox{Initialization}} \\
\gap l = w    & \mbox{field init.}\\
\gap m(x) = t & \mbox{method init.}\\
c ::= T_c \ldefs{\seq{d}} & \lindent{\mbox{Constructor}} \\[0.2em]
\Gamma ::= \seq{x \typ T} & \lindent\mbox{Environment} \\
s      ::= \seq{o \mapsto c} & \lindent\mbox{Store} \\
\ea
&
\ba[t]{l@{\hspace{10mm}}l}
L ::=      & \lindent{\mbox{Type label}} \\
\gap L_c   & \mbox{class label} \\
\gap L_a   & \mbox{abstract type label} \\[0.2em]
S,T,U,V,W ::= & \lindent\mbox{Type}\\
\gap p.L & \mbox{type selection} \\
\gap T \refine z {\seq D} & \mbox{refinement} \\
\gap T \tand T & \mbox{intersection type} \\
\gap T \tor T & \mbox{union type} \\
\gap \Top  & \mbox{top type} \\
\gap \Bot  & \mbox{bottom type} \\[0.2em]
S_c, T_c, U_c ::= & \lindent \mbox{Concrete type} \\
\multicolumn{2}{l}{\gap p.L_c ~|~ T_c \refine z {\seq D} ~|~ T_c \wedge T_c  ~|~ \Top} \\[0.2em]
D ::= & \lindent\mbox{Declaration} \\
\gap \Ldecl {L_a} S U & \mbox{abstract type decl.} \\
\gap \Ldecl {L_c} \Bot {U_c} & \mbox{{\it unique} class decl.} \\
\gap \ldecl l T   & \mbox{value declaration} \\
\gap \mdecl m S U & \mbox{method declaration}
\ea
\ea$
}
\caption{The DOT Calculus : Syntax}\label{dot-syntax}
\end{figure}

\begin{figure}
\figurebox{
\pdfbookmark[0]{Reduction}{reduction}
{\bf Reduction}\hfill\fbox{$\reduction t s {t'} {s'}$} \fbox{$\reduction p s {p'} s$}

\infrule[\textsc{sel}]
{o \mapsto T_c \ldefs{\seq{l = v}\;\seq{m(x)=t}} \in s}
{\reduction {o.l_i} s {v_i} s}

\infrule[\textsc{mapp}]
{o \mapsto T_c \ldefs{\seq{l = v'}\;\seq{m(x)=t}} \in s}
{\reduction {\anfmapp y o {m_i} v t'} s {\anfmexe y o {m_i} {\subst v {x_i} {t_i}} t'} s}

\infax[\textsc{mexe}]
{\reduction {\anfmexe y o {m_i} v t'} s {\subst v {y} {t'}} s}

\infrule[\textsc{new}]
{o \notin \dom(s)\\
c = T_c \ldefs{\seq{d}}\ c' = T_c \ldefs{\subst o x \seq{d}}\ t' = {\subst o x t}
}
{\reduction {\new x c t} s t' {s \envplus{o \mapsto c'}}}

\infrule[\textsc{context}]
{\reduction t s {t'} {s'}}
{\reduction {e[t]} s {e[t']} s'}

{\bf where} $e ::= [\,] ~|~ e.l ~|~ \anfmapp x e m p t ~|~ \anfmapp x v m e t ~|~ \anfmexe x v m e t \hspace{2cm}$
}
\caption{The DOT Calculus : Reduction}\label{dot-red}
\end{figure}

\begin{figure}
\figurebox{
\pdfbookmark[0]{Typing}{typing}
\begin{multicols}{2}[\judgement{Term Typing}{\fbox{$\Gamma;s \ts t \approxtyp T$}}]

\infrule[\textsc{path}]
{\Gamma;s \ts p \typ T' \spcomma T' \sub T}
{\Gamma;s \ts p \approxtyp T}

\infrule[\textsc{mapp}]
{\Gamma;s \ts p \ni m \typ {S \tfun T} \spcomma p' \approxtyp S\\
 \Gamma \envplus{y: T};s \ts {t'} \approxtyp T'}
{\Gamma;s \ts {\anfmapp y p m {p'} {t'}} \approxtyp {T'}}

\infrule[\textsc{new}]
{
\Gamma;s \ts T_c \wfe \spcomma T_c \expand_y \seq{\Ldecl L S U}, \seq{D} \\
\Gamma \envplus{y: T_c};s \ts \seq{S <: U} \spcomma \seq{d \approxtyp D} \spcomma {t'} \approxtyp {T'}}
{\Gamma;s \ts \new y {T_c \ldefs{\seq{d}}} {t'} \approxtyp T'}

\infrule[\textsc{mexe}]
{\Gamma;s \ts v \ni m \typ {S \tfun T} \spcomma t \approxtyp T\\
 \Gamma \envplus{y: T};s \ts {t'} \approxtyp {T'}}
{\Gamma;s \ts {\anfmexe y v m {t} t'} \approxtyp {T'}}

\end{multicols}

\linesep

\begin{multicols}{2}[\judgement{Path Typing}{\fbox{$\Gamma;s \ts p \typ T$}}]

\infrule[\textsc{var}]
{x \typ T \in \Gamma}
{\Gamma;s \ts x \typ T}

\infrule[\textsc{sel}]
{\Gamma;s \ts p \ni l \typ T'}
{\Gamma;s \ts p.l \typ T'}

\infrule[\textsc{loc}]
{o \mapsto T_c \ldefs{\seq{d}} \in s}
{\Gamma;s \ts o \typ T_c}

\end{multicols}

\linesep

\begin{multicols}{2}[\judgement{Initialization Typing}{\fbox{$\Gamma;s \ts d \approxtyp D$}}]

\infrule[\textsc{vdecl}]
{\Gamma;s \ts w \approxtyp {V}}
{\Gamma;s \ts (l = w) \approxtyp (\ldecl l V)}

\infrule[\textsc{mdecl}]
{\Gamma;s \ts S \wfe\\
 \Gamma;s \envplus{x : S} \ts t \approxtyp {T}}
{\Gamma;s \ts (m(x) = t) \approxtyp (\mdecl m S T) }

\end{multicols}

}

\caption{The DOT Calculus : Typing}\label{dot-typing}
\end{figure}

\begin{figure}
 \figurebox{
\pdfbookmark[0]{Resolution}{resolution}

      {\bf Path Resolution}\hfill{\fbox{$s \ts p \resolves o $}}

      \infax[\textsc{loc-$\resolves$}]
      {s \ts o \resolves o}

      \infrule[\textsc{path-$\resolves$}]
      {s \ts p \resolves o\\
       o \mapsto T_c \ldefs{\seq{l = o}\;\seq{m(x)=t}} \in s}
      {s \ts p.l_i \resolves o_i}

\linesep

      {\bf Path Irresolution}\hfill{\fbox{$s \ts p \irresolves p $}}

      \infax[\textsc{var-$\irresolves$}]
      {s \ts x \irresolves x}

      \infrule[\textsc{path-$\irresolves$}]
      {s \ts p \irresolves p}
      {s \ts p.l \irresolves p.l}

\linesep

      {\bf Type Resolution}\hfill{\fbox{$s \ts p.L \resolves o.L $}}

      \infrule[\textsc{tsel-$\resolves$}]
      {s \ts p \resolves o}
      {s \ts p.L \resolves o.L}

\linesep

      {\bf Optional Type Resolution}\hfill{\fbox{$s \ts p.L \optresolves p.L $}}

      \infrule[\textsc{tsel-$\resolves$-$\optresolves$}]
      {s \ts p \resolves o}
      {s \ts p.L \optresolves o.L}

      \infrule[\textsc{tsel-$\irresolves$-$\optresolves$}]
      {s \ts p \irresolves p}
      {s \ts p.L \optresolves p.L}

}
\caption{The DOT Calculus : Path and Type Resolution}\label{dot-patheq}
\end{figure}

\begin{figure}
 \figurebox{
\pdfbookmark[0]{Membership}{membership}
      {\bf Membership}\hfill{\fbox{$\Gamma;s \ts p \ni D$}}

      \infrule[\textsc{path-$\ni$}]
      {\Gamma;s \ts p \typ T \spcomma T \expand_z \seq D}
      {\Gamma;s \ts p \ni \subst p z {D_i}}

   \linesep
\pdfbookmark[0]{Expansion}{expansion}
    \begin{multicols}{2}[\judgement{Expansion}{\fbox{$\Gamma;s \ts T \expand_z \seq D$}}]
      \infrule[\textsc{any-$\expand$}]
      {\Gamma;s \ts \emptyset / T \expand'_z \seq D}
      {\Gamma;s \ts T \expand_z \seq D}
    \end{multicols}

    \begin{multicols}{2}[\judgement{Expansion'}{\fbox{$\Gamma;s \ts M / T \expand'_z \seq D$}}]  
      \infax[\textsc{$\Top$-$\expand'$}]
      {\Gamma;s \ts M/\Top \expand'_z \{\}}

      \infrule[\textsc{$\tand$-$\expand'$}]
      {\Gamma;s \ts M/T_1 \expand'_z {\seq D_1} \spcomma M/T_2 \expand'_z {\seq D_2}}
      {\Gamma;s \ts M/T_1 \tand T_2 \expand'_z {\seq D_1 \tand \seq D_2}}

      \infrule[\textsc{rfn-$\expand'$}]
      {\Gamma;s \ts M/T \expand'_z {\seq {D'}}}
      {\Gamma;s \ts M/T \refine z {\seq D} \expand'_z \seq {D'} \tand \seq D}

      \infrule[\textsc{tsel-$\expand'_1$}]
      {{s \ts p.L \optresolves q.L}\\
       {q.L \in M}}
      {\Gamma;s \ts M / p.L \expand'_z \{\}}

      \infax[\textsc{$\Bot$-$\expand'$}]
      {\Gamma;s \ts M/\Bot \expand'_z \seq{D_\Bot}}

      \infrule[\textsc{$\tor$-$\expand'$}]
      {\Gamma;s \ts M/T_1 \expand'_z {\seq D_1} \spcomma M/T_2 \expand'_z {\seq D_2}}
      {\Gamma;s \ts M/T_1 \tor T_2 \expand'_z {\seq D_1 \tor \seq D_2}}

      \infrule[\textsc{tsel-$\expand'_2$}]
      {{s \ts p.L \optresolves q.L}\\
       {q.L \not\in M}\\
       {\Gamma;s \ts q \ni \Ldecl L S U}\\
       {\Gamma;s \ts M,q.L / U \expand'_z \seq D}}
      {\Gamma;s \ts M / p.L \expand'_z \seq D}
    \end{multicols}
}
\caption{The DOT Calculus : Membership and Expansion}\label{dot-mem}
\end{figure}

\begin{figure}
  \figurebox{

\pdfbookmark[0]{Subtyping}{subtyping}
    \begin{multicols}{2}[\judgement{Subtyping}{\fbox{$\Gamma;s \ts S \sub T$}}]

%      \infrule[\textsc{trans}]
%      {\Gamma \ts S \sub T \spcomma T \sub U}
%      {\Gamma \ts S \sub U}

      \infrule[\textsc{refl}]
      {\Gamma;s \ts T \wfe}
      {\Gamma;s \ts T \sub T}

      \infrule[\textsc{refl-$\optresolves$}]
      {\Gamma;s \ts p_1.L \wfe \spcomma p_2.L \wfe\\
       s \ts p_1.L \optresolves q.L \spcomma p_2.L \optresolves q.L}
      {\Gamma;s \ts p_1.L \sub p_2.L}

      \infrule[\textsc{$\sub$-rfn}]
      {\Gamma;s \ts {T \refine z {\seq D}} \wfe
       \spcomma S \sub T \spcomma S \expand_z \seq{D'} \\
       \Gamma \envplus{z: S};s \ts \seq{D' \sub D}}
      {\Gamma;s \ts S \sub T \refine z {\seq D}}

      \infrule[\textsc{$\sub$-$\tand$}]
      {\Gamma;s \ts T \sub T_1 \spcomma T \sub T_2}
      {\Gamma;s \ts T \sub T_1 \tand T_2}

      \infrule[\textsc{$\sub$-$\tor_1$}]
      {\Gamma;s \ts T_2 \wfe \spcomma T \sub T_1}
      {\Gamma;s \ts T \sub T_1 \tor T_2}

      \infrule[\textsc{$\sub$-$\tor_2$}]
      {\Gamma;s \ts T_1 \wfe \spcomma T \sub T_2}
      {\Gamma;s \ts T \sub T_1 \tor T_2}

      \infrule[\textsc{$\sub$-tsel}]
      {\Gamma;s \ts p \ni \Ldecl L S U \spcomma S' \sub S }
      {\Gamma;s \ts S' \sub p.L}

      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      \infrule[\textsc{$\sub$-$\Top$}]
      {\Gamma;s \ts T \wfe}
      {\Gamma;s \ts T \sub \Top}


      \infrule[\textsc{$\Bot$-$\sub$}]
      {\Gamma;s \ts T \wfe}
      {\Gamma;s \ts \Bot \sub T}


      \infrule[\textsc{rfn-$\sub$}]
      {\Gamma;s \ts {T \refine z {\seq D}} \wfe
       \spcomma T \sub T'}
      {\Gamma;s \ts T \refine z {\seq D} \sub T'}

      \infrule[\textsc{$\tor$-$\sub$}]
      {\Gamma;s \ts T_1 \sub T \spcomma T_2 \sub T}
      {\Gamma;s \ts T_1 \tor T_2 \sub T}

      \infrule[\textsc{$\tand_1$-$\sub$}]
      {\Gamma;s \ts T_2 \wfe \spcomma T_1 \sub T}
      {\Gamma;s \ts T_1 \tand T_2 \sub T}

      \infrule[\textsc{$\tand_2$-$\sub$}]
      {\Gamma;s \ts T_1 \wfe \spcomma T_2 \sub T}
      {\Gamma;s \ts T_1 \tand T_2 \sub T}

      \infrule[\textsc{tsel-$\sub$}]
      {\Gamma;s \ts p \ni \Ldecl L S U \spcomma U \sub U'}
      {\Gamma;s \ts p.L \sub U'}

      \end{multicols}

    \linesep

    \begin{multicols}{2}[\judgement{Declaration subsumption}{\fbox{$\Gamma;s \ts D \sub D'$}}]

    \infrule[\textsc{tdecl-$\sub$}]
            {\Gamma;s \ts S' \sub S \spcomma T \sub T'}
            {\Gamma;s \ts (\Ldecl L S T) \sub (\Ldecl L {S'} {T'})}

    \infrule[\textsc{vdecl-$\sub$}]
            {\Gamma;s \ts T \sub T'}
            {\Gamma;s \ts (\ldecl l T) \sub (\ldecl l {T'})}

    \infrule[\textsc{mdecl-$\sub$}]
            {\Gamma;s \ts S' \sub S \spcomma T \sub T'}
            {\Gamma;s \ts (\mdecl m S T) \sub (\mdecl m {S'} {T'})}

    \end{multicols}
  }
\caption{The DOT Calculus : Subtyping and Declaration Subsumption}\label{dot-sub}
\end{figure}

\begin{figure}
  \figurebox{
\pdfbookmark[0]{Well-formedness}{wf}
       \begin{multicols}{2}[\judgement{Well-formed types}{\fbox{$\Gamma;s \ts T \wf$}}]

      \infax[\textsc{$\Top$-wf}]
      {\Gamma;s \ts \Top \wf}

      \infrule[\textsc{rfn-wf}]
      {\Gamma;s \ts T \wf \\
       \Gamma \envplus {z: T \refine z {\seq D}};s \ts \seq {D \wf}}
      {\Gamma;s \ts T \refine z {\seq D} \wf}

      \infrule[\textsc{$\tand$-wf}]
      {\Gamma;s \ts T \wf \spcomma T' \wf}
      {\Gamma;s \ts T \tand T' \wf}

      %%%%%%%%%%%%%%%%%%%%%%%%%%%

      \infax[\textsc{$\Bot$-wf}]
      {\Gamma;s \ts \Bot \wf}

      \infrule[\textsc{tsel-wf}]
      {\Gamma;s \ts p \ni \Ldecl L S U}
      {\Gamma;s \ts p.L \wf}

      \infrule[\textsc{$\tor$-wf}]
      {\Gamma;s \ts T \wf \spcomma T' \wf}
      {\Gamma;s \ts T \tor T' \wf}

    \end{multicols}

    \linesep

    \begin{multicols}{2}[\judgement{Well-formed declarations}{\fbox{$\Gamma;s \ts D \wf$}}]
      \infrule[\textsc{tdecl-wf}]
      {\Gamma;s \ts S \wf \spcomma U \wf}
      {\Gamma;s \ts \Ldecl L S U \wf}

      \infrule[\textsc{vdecl-wf}]
      {\Gamma;s \ts T \wf}
      {\Gamma;s \ts \ldecl l T \wf}

      \infrule[\textsc{mdecl-wf}]
      {\Gamma;s \ts S \wf \spcomma U \wf}
      {\Gamma;s \ts \mdecl m S U \wf}

    \end{multicols}

    \linesep

    \begin{multicols}{2}[\judgement{Well-formed and expanding types}{\fbox{$\Gamma;s \ts T \wfe$}}]
      \infrule[\textsc{wfe}]
      {\Gamma;s \ts T \wf \spcomma T \expand_z \seq{D}}
      {\Gamma;s \ts T \wfe}
    \end{multicols}
  }

\caption{The DOT Calculus : Well-Formedness}\label{dot-wf}
\end{figure}


\begin{figure}
\figurebox{
\pdfbookmark[0]{Declaration Lattice}{lattice}
\bda{lcl@{\gap}l}
    
      \dom(\seq D \tand \seq {D'}) &~=~& \dom(\seq{D}) \cup \dom(\seq{D'}) \\
      \dom(\seq D \tor \seq {D'}) &=& \dom(\seq{D}) \cap \dom(\seq{D'}) \\[0.5em]
      (D \tand D')(L) &=&
        \Ldecl L {(S \tor S')} {(U \tand U')} & \mbox{if~} (\Ldecl L S U) \in \seq{D} \;\mbox{and}\; (\Ldecl L {S'} {U'}) \in \seq{D'} \\
        &=& D(L) & \mbox{if~} L \notin \dom(\seq{D'}) \\
        &=& D'(L) & \mbox{if~} L \notin \dom(\seq{D}) \\
      (D \tand D')(m) &=&
        \mdecl m {(S \tor S')} {(U \tand U')} & \mbox{if~} (\mdecl m S U) \in \seq{D} \;\mbox{and}\; (\mdecl m {S'} {U'}) \in \seq{D'} \\
        &=& D(m) & \mbox{if~} m \notin \dom(\seq{D'}) \\
        &=& D'(m) & \mbox{if~} m \notin \dom(\seq{D}) \\
      (D \tand D')(l) &=&
        \ldecl l {T \tand T'} & \mbox{if~} (\ldecl l T) \in \seq{D} \;\mbox{and}\; (\ldecl l {T'}) \in \seq{D'} \\
        &=& D(l) & \mbox{if~} l \notin \dom(\seq{D'}) \\
        &=& D'(l) & \mbox{if~} l \notin \dom(\seq{D}) \\[0.5em]
      (D \tor D')(L) &=&
        \Ldecl L {(S \tand S')} {(U \tor U')} & \mbox{if~} (\Ldecl L S U) \in \seq{D} \;\mbox{and}\; (\Ldecl L {S'} {U'}) \in \seq{D'} \\
      (D \tor D')(m) &=&
        \mdecl m {(S \tand S')} {(U \tor U')} & \mbox{if~} (\mdecl m S U) \in \seq{D} \;\mbox{and}\; (\mdecl m {S'} {U'}) \in \seq{D'} \\
      (D \tor D')(l) &=&
        \ldecl l {T \tor T'} & \mbox{if~} (\ldecl l T) \in \seq{D} \;\mbox{and}\; (\ldecl l {T'}) \in \seq{D'} 
    \eda

Sets of declarations form a lattice with the given meet $\wedge$ and
join $\vee$, the empty set of declatations as the top element, and the
bottom element $\seq{D_\Bot}$, Here $\seq{D_\Bot}$ is the set of
declarations that contains for every term label $l$ the declaration
$\ldecl l \Bot$, for every type label $L$ the declaration $\Ldecl L
\Top \Bot$ and for every method label $m$ the declaration $\mdecl m
\Top \Bot$.
}
\caption{The DOT Calculus : Declaration Lattice}\label{dot-decl}
\end{figure}

\end{document}
